"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubClient = void 0;
const rest_1 = require("@octokit/rest");
class GitHubClient {
    constructor(githubToken) {
        this.octokit = new rest_1.Octokit({
            auth: githubToken,
        });
    }
    async postReviewComment(owner, repo, pullNumber, reviewSummary) {
        try {
            // Create the main review with overall summary
            const reviewBody = this.formatMainReviewBody(reviewSummary);
            await this.octokit.rest.pulls.createReview({
                owner,
                repo,
                pull_number: pullNumber,
                body: reviewBody,
                event: this.determineReviewEvent(reviewSummary.overallScore),
            });
            // Post individual line comments
            for (const comment of reviewSummary.comments) {
                if (comment.line) {
                    await this.postLineComment(owner, repo, pullNumber, comment);
                }
            }
        }
        catch (error) {
            console.error('Error posting review to GitHub:', error);
            throw error;
        }
    }
    async postLineComment(owner, repo, pullNumber, comment) {
        try {
            // Get the commit SHA for the PR
            const { data: pr } = await this.octokit.rest.pulls.get({
                owner,
                repo,
                pull_number: pullNumber,
            });
            await this.octokit.rest.pulls.createReviewComment({
                owner,
                repo,
                pull_number: pullNumber,
                commit_id: pr.head.sha,
                path: comment.file,
                line: comment.line,
                body: this.formatLineComment(comment),
            });
        }
        catch (error) {
            console.error(`Error posting line comment for ${comment.file}:${comment.line}:`, error);
            // Don't throw here - continue with other comments
        }
    }
    formatMainReviewBody(reviewSummary) {
        const scoreEmoji = this.getScoreEmoji(reviewSummary.overallScore);
        return `
## 🤖 AI Code Review Results ${scoreEmoji}

**Overall Score: ${reviewSummary.overallScore}/100**

### 📋 Summary
${reviewSummary.summary}

### 💡 Recommendations
${reviewSummary.recommendations.map((rec, index) => `${index + 1}. ${rec}`).join('\n')}

### 📊 Review Statistics
- **Total Comments**: ${reviewSummary.comments.length}
- **High Priority Issues**: ${reviewSummary.comments.filter(c => c.priority === 'high').length}
- **Medium Priority Issues**: ${reviewSummary.comments.filter(c => c.priority === 'medium').length}
- **Low Priority Issues**: ${reviewSummary.comments.filter(c => c.priority === 'low').length}

---
*This review was generated by AI Code Reviewer powered by Claude* 🚀
    `.trim();
    }
    formatLineComment(comment) {
        const priorityEmoji = this.getPriorityEmoji(comment.priority);
        const typeEmoji = this.getTypeEmoji(comment.type);
        return `${typeEmoji} **${comment.type.toUpperCase()}** ${priorityEmoji}\n\n${comment.body}`;
    }
    determineReviewEvent(score) {
        if (score >= 80) {
            return 'APPROVE';
        }
        else if (score < 60) {
            return 'REQUEST_CHANGES';
        }
        else {
            return 'COMMENT';
        }
    }
    getScoreEmoji(score) {
        if (score >= 90)
            return '🎉';
        if (score >= 80)
            return '✅';
        if (score >= 70)
            return '👍';
        if (score >= 60)
            return '⚠️';
        return '🚨';
    }
    getPriorityEmoji(priority) {
        switch (priority) {
            case 'high': return '🔴';
            case 'medium': return '🟡';
            case 'low': return '🔵';
            default: return '⚪';
        }
    }
    getTypeEmoji(type) {
        switch (type) {
            case 'issue': return '🐛';
            case 'suggestion': return '💭';
            case 'improvement': return '⚡';
            case 'praise': return '👏';
            default: return '💬';
        }
    }
    async addPullRequestLabel(owner, repo, pullNumber, score) {
        try {
            const label = this.getScoreLabel(score);
            await this.octokit.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pullNumber,
                labels: [label],
            });
        }
        catch (error) {
            console.error('Error adding label to PR:', error);
            // Don't throw - labels are optional
        }
    }
    getScoreLabel(score) {
        if (score >= 90)
            return 'ai-review: excellent';
        if (score >= 80)
            return 'ai-review: good';
        if (score >= 70)
            return 'ai-review: needs-improvement';
        if (score >= 60)
            return 'ai-review: review-required';
        return 'ai-review: needs-work';
    }
}
exports.GitHubClient = GitHubClient;
//# sourceMappingURL=github-client.js.map